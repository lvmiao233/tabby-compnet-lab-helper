# NettyTabby Plugin

GNS3实验助手的Tabby终端插件

## 🚀 快速开始

### 1. 构建插件

```bash
# 安装依赖
npm install

# 构建插件
npm run build:prod
```

### 2. 测试插件

#### 方式一：一键启动（推荐）
```bash
# Windows PowerShell - 一键测试
.\start-dev.ps1
```

#### 方式二：手动测试
```bash
# 先运行配置检查
.\test-plugin.ps1

# 然后在新终端中启动Tabby
tabby --debug
```

### 3. 故障排除

#### 构建失败
```bash
# 清理node_modules重新安装
rm -rf node_modules
npm install
npm run build:prod
```

#### 插件不显示
1. 确保Tabby已完全关闭
2. 检查环境变量是否正确设置
3. 查看Tabby开发者工具控制台错误
4. 确认插件文件存在且不为空

## 📋 当前功能

### ✅ 已实现
- [x] 基础插件框架和构建系统
- [x] 工具栏按钮提供者 (ToolbarButtonProvider)
- [x] 按钮点击响应和调试输出
- [x] 插件模块注册和依赖注入
- [x] 开发环境配置和测试脚本
- [x] **🎯 捕获模式状态管理服务 (CaptureService)**
- [x] **📊 终端底部状态栏显示** - **核心功能**
- [x] **⌨️ 键盘事件处理 (Enter/Esc)**
- [x] **🔄 实时状态更新**
- [x] **🎨 状态栏UI设计和样式**
- [x] **📊 详细的调试日志系统**

### 🔄 待开发
- [x] **🔍 终端缓冲区访问** - **xterm.js集成已实现**
- [x] **🎯 命令交互区块识别** - **智能解析算法已实现**
- [x] **⚡ 自动缓冲区解析** - **进入捕获模式时自动执行**
- [x] **🎯 智能区块识别算法** - **改进的Windows CMD支持**
- [x] **🎮 区块选择和取消选择** - **键盘快捷键交互已实现**
- [x] **🔄 区块浏览导航** - **方向键导航已实现**
- [x] **🎨 区块高亮显示** - **xterm装饰器+DOM高亮**
- [x] **🪟 选择窗口界面** - **HTML模态框选择区块**
- [x] **🖼️ 图片导出功能** - **Canvas渲染为PNG图片**
- [ ] **⚙️ 配置下载位置** - **可配置图片保存目录 (TODO)**

### 🎯 **最新修复 (v0.2.15)** - 界面刷新修复版本
- **🔧 解决方案A**: 简化的提示符识别算法 - 不再依赖复杂正则
- **🎨 解决方案B**: xterm.js原生装饰器API - 使用registerDecoration进行高亮
- **🔄 智能回退**: 当原生方法失败时自动回退到DOM操作
- **🪟 选择窗口**: HTML模态框替代终端高亮，提供可靠的选择界面
- **🖼️ 图片导出**: Canvas渲染终端内容为PNG图片，自动下载
- **📋 一键复制**: 导出同时自动复制到剪贴板，无需二次确认
- **🔔 桌面通知**: 右上角显示成功/失败提示，3秒后自动消失
- **🎨 彩色日志**: 控制台输出带颜色标识，方便跟踪导出过程
- **🔄 智能下载**: 自动尝试直接下载，失败时提供新窗口备用方案
- **🛡️ 权限处理**: 优雅处理剪贴板权限问题，提供备用方案
- **⏱️ 异步优化**: 优化剪贴板和下载的执行顺序
- **🎯 分离按钮**: 复制和下载分离，支持不同使用场景
- **📝 Typora集成**: 专门的复制按钮，完美支持文档编辑器
- **💾 文件保存**: 下载按钮提供本地文件备份功能
- **🔄 倒序显示**: 选择窗口中最新命令显示在顶部，方便快速选择
- **📋 原始顺序**: 图片生成保持终端中的原始命令顺序，无随意改变
- **📏 动态高度**: 图片高度根据内容自适应，移除固定最小高度
- **📏 自适应宽度**: 图片宽度根据内容自适应，移除固定最小宽度
- **📝 原始内容**: 直接使用终端原始内容，不进行命令/输出分离处理
- **🎯 精准还原**: 完全反映学生实验的实际情况，无任何修改
- **🖼️ 选择窗口**: 显示原始命令内容，去掉卡片标题和分离显示
- **🔢 实时计数**: 按钮数量显示实时更新，反映选中状态
- **📏 自适应宽度**: 移除图片固定最小宽度，完全根据内容自适应
- **🎯 简洁界面**: 去掉区块标题，只用高亮标记选择状态
- **📝 简化按钮**: 去掉按钮数字显示，界面更简洁
- **📜 自然排序**: 区块正序显示，自动滚动到底部符合终端习惯
- **🔄 选择模式切换**: 支持按区块和按行两种选择模式
- **🎛️ 交互式开关**: 窗口内可切换选择模式的开关按钮
- **📊 区块信息**: 显示每个区块的行数和序号信息
- **🎯 极简设计**: 完全移除区块标题和边框，纯净内容显示
- **🔘 行选择开关**: 在全选/清空按钮旁添加按行选择开关
- **🎨 高亮标记**: 只用边框和背景色标记选择状态，无任何多余UI
- **📋 行级选择**: 按行选择模式下可单独选择每一行
- **🎯 精确微调**: 解决命令识别错误，支持精确选择
- **📊 行计数显示**: 实时显示选中的行数而非区块数
- **💾 智能导出**: 按行模式只导出选中的行内容
- **🔄 实时界面刷新**: 切换选择模式时自动重新渲染界面
- **📱 状态同步**: 区块与行选择状态完美同步
- **⚡ 即时切换**: 无需刷新即可看到界面变化
- **📊 详细调试**: 增强的调试信息帮助问题定位
- **🔍 增强调试**: 详细的终端对象信息和DOM结构分析
- **🔄 智能回退**: 当装饰器API失败时自动回退到DOM操作
- **📊 多重策略**: 尝试3种不同的装饰器API调用方式

## 📸 图片导出说明

### **🖼️ 导出图片特性**
- **专业外观**: 深色主题，类似VS Code终端风格
- **完整信息**: 包含时间戳、区块数量等元数据
- **原始内容**: 完全保留终端的原始显示，不进行任何处理
- **动态高度**: 图片高度根据内容自适应，无固定最小高度
- **智能下载**: 自动尝试直接下载，失败时提供备用方案
- **一键复制**: 同时自动复制图片到剪贴板（需要权限）
- **桌面通知**: 右上角显示成功/失败提示
- **彩色日志**: 控制台输出带颜色标识，方便跟踪
- **多重回退**: 如果下载失败，自动在新窗口中显示图片供右键保存
- **倒序显示**: 选择窗口中最新命令显示在顶部，方便选择
- **原始顺序**: 图片生成保持终端中的原始命令顺序
- **文件名格式**: `terminal-commands-{时间戳}-{区块数}-blocks.png`

### **🎨 界面预览**

#### **选择窗口界面**
```
┌─────────────────────────────────────┐
│ 选择要导出的命令区块               │
│                                     │
│ D:\CompNetDocRefactor>ls            │ ← 按区块选择模式
│ 'ls' 不是内部或外部命令...          │ ← 整个区块高亮选中
│                                     │
│ ■ D:\CompNetDocRefactor>dir         │ ← 按行选择模式示例
│ □ 驱动器 D 中的卷是 工作素材        │ ← 可单独选择每一行
│ ■ 卷的序列号是 3E61-4819            │ ← 选中行高亮显示
│ □ D:\CompNetDocRefactor>cd          │ ← 未选中行
│ ■ C:\Users>                         │ ← 选中行
│                                     │
│ ──────────────────────────────────  │
│ [全选] [清空] [■ 按行选择]    [复制] [下载] [取消] │ ← 行选择开关（实时切换界面）
└─────────────────────────────────────┘
```

### **🎨 图片样式预览**
```
┌─────────────────────────────────────────┐
│ 终端命令导出                           │
│ 2024/8/9 14:30    2 个命令区块         │
│ ──────────────────────────────────────  │
│                                         │
│ D:\CompNetDocRefactor>ls                │
│ 'ls' 不是内部或外部命令，也不是可运行的│
│ 程序或批处理文件。                      │
│                                         │
│ D:\CompNetDocRefactor>dir               │
│ 驱动器 D 中的卷是 工作素材              │
│ 卷的序列号是 3E61-4819                  │
│ D:\CompNetDocRefactor 的目录             │
│                                         │
│ ──────────────────────────────────────  │
│ 由 NettyTabby 插件生成                  │
└─────────────────────────────────────────┘
```

### **🔄 智能排序系统**

#### **选择窗口：倒序显示**
```
选择窗口中的区块顺序：
─────────────────────────
🆕 最新执行的命令 (显示在顶部)
   └─ 方便快速选择刚执行的命令

🕒 较早执行的命令
   └─ 按时间倒序列出

🕐 最先执行的命令 (显示在底部)
   └─ 最早的命令
```

#### **图片导出：原始顺序**
```
生成的图片保持终端原始顺序：
─────────────────────────
📄 最先执行的命令 (图片顶部)
   └─ 按时间正序列出

📄 后续命令
   └─ 符合阅读习惯

🆕 最新执行的命令 (图片底部)
   └─ 最新的命令
```

**🎯 设计理念**：
- **选择时**：最新命令在前，方便快速选择
- **导出时**：原始顺序不变，符合阅读习惯
- **内容处理**：完全保留原始终端显示，无任何修改

### **🔔 桌面通知系统**

导出完成后，会在右上角显示桌面通知：

**✅ 成功通知 (绿色):**
```
┌─────────────────────────────────────┐
│ ✅ 图片已导出并复制到剪贴板！     │
└─────────────────────────────────────┘
```

**⚠️ 备用通知 (橙色):**
```
┌─────────────────────────────────────┐
│ ⚠️ 图片已下载，但复制到剪贴板失败 │
└─────────────────────────────────────┘
```

- **自动显示**: 导出完成后立即显示
- **动画效果**: 平滑的淡入淡出动画
- **智能定位**: 固定在右上角，不影响操作
- **自动消失**: 3-4秒后自动消失

### **🎨 彩色控制台日志**

图片导出过程中会输出详细的彩色日志：

```
🖼️ NettyTabby图片导出开始     [绿色背景]
📊 准备导出 2 个命令区块
🎨 开始将HTML渲染为图片...    [橙色背景]
📐 图片尺寸: 800x600          [紫色背景]
✏️ 开始渲染终端内容到Canvas... [灰色背景]
✅ Canvas渲染完成             [绿色背景]
💾 开始下载图片...            [蓝色背景]
📁 文件名: terminal-commands-... [青色背景]
✅ 图片下载触发成功           [绿色背景]
📁 如果浏览器弹出保存对话框，请选择保存位置 [橙色背景]
💡 提示: 某些浏览器会弹出保存对话框，这是正常行为 [紫色背景]
📋 正在复制图片到剪贴板...    [绿色背景]
✅ 图片已复制到剪贴板！       [绿色背景]
💡 现在可以在其他应用中直接粘贴使用了 [蓝色背景]

[如果剪贴板失败:]
⚠️ 剪贴板复制失败，可能是权限问题 [橙色背景]

[如果下载也失败，备用方案:]
🔄 使用备用下载方案...       [橙色背景]
✅ 已在新窗口中打开图片，请右键保存 [绿色背景]
```

## 🛠️ 开发说明

### 项目结构
```
tabby-netty-plugin/
├── src/
│   ├── index.ts              # 插件入口和按钮提供者
│   ├── services/
│   │   └── capture.service.ts # 捕获模式状态管理服务
│   └── components/           # Angular组件 (待开发)
├── dist/                     # 构建输出
├── package.json              # 项目配置
├── tsconfig.json             # TypeScript配置
├── webpack.config.js         # 构建配置
├── test-plugin.ps1           # 配置验证脚本
├── start-dev.ps1             # 一键测试脚本
└── README.md                 # 详细说明文档
```

## 🧪 新功能测试指南

### 最新版本功能 (v0.2.2)

#### 📊 终端底部状态栏显示 + 🔍 智能缓冲区解析

**🎯 核心功能实现**:
- **状态栏位置**: 终端底部，完全不占用其他界面空间
- **条件显示**: 仅在捕获模式下显示状态栏
- **实时更新**: 状态变化立即反映在状态栏中
- **键盘支持**: Enter键完成，Esc键取消
- **🔍 智能解析**: 自动识别命令交互区块
- **⚡ 自动执行**: 进入捕获模式时自动解析终端内容
- **🔧 深度集成**: 通过AppService获取活动终端实例，完美集成Tabby架构
- **🪟 分割窗口支持**: 自动处理SplitTabComponent，获取聚焦的子标签页
- **🔍 智能标签页识别**: 支持所有终端类型和分割窗口场景
- **🎯 改进区块识别**: 优化Windows CMD提示符识别，支持复杂路径
- **🎨 区块高亮**: 选中区块的高亮显示框架

**测试步骤**:
1. 启动Tabby，打开任意终端标签页，输入一些命令
2. 点击工具栏的 📷 "Netty捕获" 按钮
3. 观察终端底部是否出现状态栏：
   ```
   [🎯 Netty捕获] | 区块: 0 | 快捷键: Enter完成, Esc取消 | 状态: 就绪
   ```
4. 系统会自动解析终端缓冲区，识别命令交互区块
5. **自动弹出选择窗口**，显示所有识别到的命令区块
6. 在选择窗口中可以：
   - **点击区块** 选择/取消选择（高亮标记状态）
   - **按行选择开关** 切换到按行选择模式，可单独选择每一行（界面实时刷新）
   - **行级点击** 在行选择模式下，点击单独的行进行精确选择
   - **全选按钮** 选择所有区块（区块模式）或所有行（行模式）
   - **清空按钮** 取消所有选择
   - **📋 复制到剪贴板** - 只复制图片到剪贴板（用于Typora/Word）
   - **💾 下载并复制** - 同时下载文件并复制到剪贴板
7. **正序显示** - 命令按执行顺序显示，自动滚动到底部符合终端习惯
8. **智能选择** - 根据使用场景选择合适的导出方式
9. **彩色日志** - 在浏览器开发者工具控制台查看详细的导出过程
10. **桌面通知** - 右上角显示操作结果和状态
11. 按 Esc 键取消捕获

**预期结果**:
```
控制台输出:
🚀 NettyTabby插件已加载 - 终端底部状态栏模式
📸 CaptureService 初始化
🎯 进入捕获模式
🔍 开始获取当前终端实例...
✅ 找到活动标签页: ConnectableTerminalTabComponent
✅ 获取到frontend实例
🎉 成功获取xterm实例!
📊 开始解析终端缓冲区...
🔍 开始详细分析每一行...
🔍 行 4: "D:\CompNetDocRefactor>ls" -> 是提示符 ✅
🔍 行 7: "D:\CompNetDocRefactor>dir" -> 是提示符 ✅
📦 保存区块: 行 4-6 (ls命令区块)
📦 保存区块: 行 7-24 (dir命令区块)
📝 总共读取到 25 行有效内容
🎯 识别到 2 个命令交互区块

🎨 高亮区块: block-0 (行 4-6)
🔧 尝试使用xterm.js装饰器API进行高亮...
🔍 终端对象信息: {
  hasRegisterDecoration: true/false,  // API可用性
  hasRegisterMarker: true/false,      // Marker可用性
  terminalType: "Terminal",           // 终端类型
  terminalMethods: [...]              // 可用方法列表
}

✅ 方法1成功: 使用marker + decoration  // 或其他成功的方法
✅ 已为第4行添加xterm装饰器
✅ 已为第5行添加xterm装饰器
✅ 已为第6行添加xterm装饰器
💾 已存储 3 个装饰器引用 for block-0
🎨 区块 block-0 高亮完成: 3 个装饰器

[如果装饰器API失败，将看到:]
⚠️ xterm装饰器API不可用，检查替代方法...
🔍 开始DOM高亮回退方案...
✅ 找到终端容器: DIV.terminal
🎯 找到 XX 个行元素
📍 区块信息: block-0, 行范围: 4-6
✅ 已高亮DOM元素: DIV.xterm-row (行 4)
✅ 已高亮DOM元素: DIV.xterm-row (行 5)
✅ 已高亮DOM元素: DIV.xterm-row (行 6)
🎨 DOM高亮完成: 3/3 行已高亮

→ Ctrl+右箭头 - 浏览下一个区块
→ Ctrl+空格 - 选择区块
🄰 Ctrl+A - 选择所有区块

🪟 显示区块选择窗口...
✅ 区块选择窗口已显示 (简洁界面，自动滚动到底部)

[用户在选择窗口中操作 - 点击区块切换选择，或开启按行选择开关（界面实时刷新）进行精确行级选择]

**场景1: 只复制到剪贴板（用于Typora/Word）**
用户点击: 📋 复制到剪贴板
🖼️ NettyTabby图片导出开始     [绿色背景]
📊 准备导出 2 个命令区块
🎨 开始将HTML渲染为图片...    [橙色背景]
📐 图片尺寸: 800x600          [紫色背景]
✏️ 开始渲染终端内容到Canvas... [灰色背景]
✅ Canvas渲染完成             [绿色背景]
📋 正在复制图片到剪贴板...    [绿色背景]
✅ 图片已复制到剪贴板！       [绿色背景]
💡 现在可以在其他应用中直接粘贴使用了 [蓝色背景]
✅ 成功导出 2 个命令区块为图片！
[窗口保持打开，用户可以继续操作]

**场景2: 下载并复制**
用户点击: 💾 下载并复制
🖼️ NettyTabby图片导出开始     [绿色背景]
📊 准备导出 2 个命令区块
🎨 开始将HTML渲染为图片...    [橙色背景]
📐 图片尺寸: 800x600          [紫色背景]
✏️ 开始渲染终端内容到Canvas... [灰色背景]
✅ Canvas渲染完成             [绿色背景]
💾 开始下载图片...            [蓝色背景]
📁 文件名: terminal-commands-... [青色背景]
✅ 图片下载成功               [绿色背景]
📁 文件已保存到下载文件夹     [蓝色背景]
📋 正在复制图片到剪贴板...    [绿色背景]
✅ 图片已复制到剪贴板！       [绿色背景]
💡 现在可以在其他应用中直接粘贴使用了 [蓝色背景]
✅ 成功导出 2 个命令区块为图片！
🎉 完成捕获，共选择 2 个区块
[窗口自动关闭]
```

### **🔧 最新修复说明**

#### **✅ 图片高度问题修复**
**问题**：图片有固定最小高度600px，导致内容少的图片也很大
**解决方案**：
```typescript
// 修复前
const height = Math.max(rect.height, 600) // 固定最小600px

// 修复后
const height = rect.height // 根据内容动态调整
```
**效果**：图片高度现在完全根据内容自适应，内容少的图片会更紧凑

#### **✅ 内容处理问题修复**
**问题**：导出的内容被处理，显示"未知命令"，提示符不正常
**解决方案**：
```typescript
// 修复前：分离命令和输出
const command = block.command || '未知命令'
const output = block.output || '无输出'

// 修复后：直接使用原始内容
const content = block.content // 完全原始
```
**效果**：现在导出的图片完全反映终端的原始显示，学生实验内容得到精准还原

#### **✅ 选择窗口内容修复**
**问题**：选择窗口仍然显示分离的命令和输出，而不是原始内容
**解决方案**：
```typescript
// 修复前：分离显示
<strong>命令:</strong> ls
<strong>输出:</strong> ...

// 修复后：原始内容
D:\CompNetDocRefactor>ls
'ls' 不是内部或外部命令...
```

#### **✅ 按钮计数显示修复**
**问题**：选择区块后按钮显示的数量仍然为0
**解决方案**：
```typescript
// 在点击事件中添加更新逻辑
item.onclick = (e) => {
    block.selected = !block.selected
    updateSelectedStyle()
    // 更新按钮文本显示
    const modalFooter = container.closest('.netty-selection-modal')?.querySelector('.netty-modal-footer') as HTMLElement
    if (modalFooter) {
        this.updateModalDisplay(container, allBlocks, modalFooter)
    }
}
```

#### **✅ 宽度自适应修复**
**问题**：图片有固定最小宽度800px，导致空白
**解决方案**：
```typescript
// 修复前：固定最小宽度
const width = Math.max(rect.width, 800)

// 修复后：完全自适应
const width = rect.width
```

#### **✅ 选择窗口优化**
**问题**：选择窗口仍然显示分离的命令/输出，去掉卡片标题
**解决方案**：
```typescript
// 修复前：分离显示 + 卡片标题
区块 1 (行 4-6)
命令: ls
输出: 'ls' 不是内部...

// 修复后：直接显示原始内容，无标题
D:\CompNetDocRefactor>ls
'ls' 不是内部或外部命令...
```

#### **✅ 按钮计数实时更新**
**问题**：选择区块后按钮显示的数量仍然为0
**解决方案**：
```typescript
// 在所有选择事件中添加更新逻辑
checkbox.onchange = () => {
    block.selected = checkbox.checked
    updateSelectedStyle()
    // 实时更新按钮文本
    this.updateModalDisplay(container, allBlocks, modalFooter)
}
```

**效果**：现在选择区块后，按钮会立即显示正确的选中数量

#### **✅ 界面简化修复**
**问题**：区块标题和按钮数字显示造成界面混乱
**解决方案**：
```typescript
// 修复前：区块有标题和数字
区块 1 (行 4-6)    📋 复制到剪贴板 (2)
[命令内容]         💾 下载并复制 (2)

// 修复后：简洁无标题无数字
□ [命令内容]       📋 复制到剪贴板
                   💾 下载并复制
```

#### **✅ 显示顺序优化**
**问题**：倒序显示不符合终端习惯
**解决方案**：
```typescript
// 修复前：倒序显示（最新在前）
for (let i = blocks.length - 1; i >= 0; i--)

// 修复后：正序显示，自动滚动到底部
for (let i = 0; i < blocks.length; i++)
setTimeout(() => blocksList.scrollTop = blocksList.scrollHeight, 10)
```

**效果**：命令按执行顺序显示，自动滚动到底部，符合用户使用习惯

#### **✅ 界面极简优化**
**问题**：复选框和标题造成界面混乱，影响用户体验
**解决方案**：
```typescript
// 修复前：有复选框和标题的区块
□ 区块 1 (行 4-6) ← 冗余UI元素
[命令内容]

// 修复后：极简设计，只用高亮标记
2 行 · 区块 1 ← 简洁信息显示
[命令内容] ← 只用边框和背景色标记选择
```

#### **✅ 选择模式切换**
**问题**：缺少灵活的选择模式，难以满足不同使用场景
**解决方案**：
```typescript
// 添加选择模式状态管理
private selectionMode: 'block' | 'line' = 'block'

// 交互式切换开关
const modeSwitch = document.createElement('button')
modeSwitch.textContent = this.selectionMode === 'block' ? '📦 按区块选择' : '📝 按行选择'
```

**效果**：用户可以在按区块选择和按行选择之间实时切换，满足不同的工作需求

#### **✅ 极简界面优化**
**问题**：区块标题仍然显示"X 行 · 区块 X"，不够简洁
**解决方案**：
```typescript
// 修复前：有标题的区块
2 行 · 区块 1 ← 冗余标题
[命令内容]

// 修复后：完全移除标题
[命令内容] ← 纯净内容显示，无任何包装
```

#### **✅ 行选择开关**
**问题**：缺少微调功能，无法修正命令识别错误
**解决方案**：
```typescript
// 在全选/清空按钮旁添加开关
□ 按行选择 ← 复选框开关

// 开关状态管理
lineSelectCheckbox.onchange = () => {
    this.selectionMode = lineSelectCheckbox.checked ? 'line' : 'block'
    console.log(`🔄 切换到${this.selectionMode === 'block' ? '按区块选择' : '按行选择'}模式`)
}
```

**效果**：用户可以切换到按行选择模式，微调命令识别结果，即使区块识别有问题也能得到正确结果

#### **✅ 完整按行选择功能**
**问题**：按行选择开关启用后仍然按区块选择，无法进行精确的行级选择
**解决方案**：
```typescript
// 为每一行创建单独的可选择元素
lines.forEach((line, lineIndex) => {
    const lineElement = document.createElement('div')
    lineElement.onclick = (e) => {
        e.stopPropagation()
        block.selectedLines![lineIndex] = !block.selectedLines![lineIndex]
        updateLineStyle()
        // 更新整体选择状态和UI
    }
})
```

#### **✅ 智能导出处理**
**问题**：按行选择模式下需要只导出选中的行，而不是整个区块
**解决方案**：
```typescript
// 在行选择模式下只导出选中的行
if (this.selectionMode === 'line' && block.selectedLines) {
    const selectedContent = lines
        .filter((line, lineIndex) => block.selectedLines![lineIndex])
        .join('\n')
    // 只导出选中的行内容
}
```

#### **✅ 行计数显示**
**问题**：需要显示选中的行数而不是区块数
**解决方案**：
```typescript
// 行选择模式：计算选中的行数
if (this.selectionMode === 'line') {
    let selectedLinesCount = 0
    blocks.forEach(block => {
        if (block.selectedLines) {
            selectedLinesCount += block.selectedLines.filter(selected => selected).length
        }
    })
    displayText = `${selectedLinesCount} 行已选中`
}
```

**效果**：实现了完整的按行选择功能，支持精确选择每一行，解决命令识别错误的问题

#### **✅ 界面刷新机制修复**
**问题**：启用按行选择模式后，卡片仍然是按区块显示的，列表完全没有更新
**解决方案**：
```typescript
// 新增界面刷新机制
private refreshBlockDisplay(blocksList: HTMLElement, blocks: CaptureBlock[], modalFooter: HTMLElement): void {
    // 1. 清空现有的区块列表
    while (blocksList.firstChild) {
        blocksList.removeChild(blocksList.firstChild)
    }

    // 2. 重新为每个区块创建显示元素
    for (let i = 0; i < blocks.length; i++) {
        const block = blocks[i]
        // 根据当前选择模式重新创建元素
        const blockItem = this.createBlockItem(block, i, blocksList, blocks)
        blocksList.appendChild(blockItem)
    }

    // 3. 重新应用滚动和更新显示
    setTimeout(() => blocksList.scrollTop = blocksList.scrollHeight, 10)
    this.updateModalDisplay(blocksList, blocks, modalFooter)
}
```

#### **✅ 状态同步机制**
**问题**：切换模式时需要保持选择状态的同步
**解决方案**：
```typescript
// 切换到行选择模式时
if (this.selectionMode === 'line') {
    if (!block.selectedLines) {
        // 根据区块选择状态初始化所有行
        block.selectedLines = new Array(lines.length).fill(block.selected)
    }
}

// 切换回区块选择模式时
if (this.selectionMode === 'block' && block.selectedLines) {
    // 根据行选择状态更新区块状态
    block.selected = block.selectedLines.some(selected => selected)
    delete block.selectedLines
}
```

**效果**：现在切换选择模式时，界面会立即重新渲染，显示正确的选择模式，状态完美同步

### **💡 浏览器下载行为说明**

#### **为什么会出现保存对话框？**
这是浏览器的**安全机制和正常行为**，不是插件问题：

- **Chrome/Edge**: 某些版本会弹出"保存为"对话框
- **Firefox**: 通常直接下载，但也可能弹出对话框
- **Safari**: 通常弹出对话框让用户选择位置

#### **如何处理保存对话框**
1. **直接选择保存位置**：在弹出的对话框中选择文件夹并点击保存
2. **设置默认下载位置**：修改浏览器设置，让文件自动保存到指定文件夹
3. **使用备用方案**：如果下载完全失败，会在新窗口中显示图片供右键保存

### **📁 找不到下载文件？**

如果导出后找不到下载的图片文件，请尝试：

1. **检查浏览器下载设置**：
   - Chrome: `chrome://settings/downloads`
   - Firefox: 设置 → 常规 → 下载
   - Edge: 设置 → 下载

2. **查看默认下载位置**：
   - Windows: `C:\Users\{用户名}\Downloads\`
   - macOS: `~/Downloads/`
   - Linux: `~/Downloads/`

3. **检查文件名格式**：
   - 文件名: `terminal-commands-{时间戳}-{区块数}-blocks.png`
   - 例如: `terminal-commands-1723456789012-3-blocks.png`

4. **使用备用下载方案**：
   - 如果自动下载失败，会在新窗口中打开图片
   - 右键点击图片 → "图片另存为"

**🔧 调试信息**:
- 如果看到"未找到活动标签页"，说明当前没有活动的标签页
- 如果看到"检测到SplitTabComponent，尝试获取聚焦的子标签页"，说明当前在分割窗口中
- 如果看到"获取到聚焦的子标签页"，说明成功找到分割窗口中的活动终端
- 如果看到"当前活动标签页不是终端标签页"，说明当前活动的是其他类型的标签页（如设置页）
- 如果看到"终端组件没有frontend属性"，说明终端组件未正确初始化
- 如果看到"Frontend没有xterm属性"，说明前端渲染器未正确加载

### **🔍 如何查看彩色控制台日志**

1. **打开浏览器开发者工具**：
   - Chrome/Edge: 按 `F12` 或 `Ctrl+Shift+I`
   - Firefox: 按 `F12` 或 `Ctrl+Shift+K`

2. **切换到控制台(Console)标签页**

3. **查看彩色日志输出**：
   - 绿色背景: 成功操作
   - 蓝色背景: 信息提示
   - 橙色背景: 渲染过程
   - 紫色背景: 配置信息
   - 红色背景: 错误信息

4. **过滤NettyTabby日志**：
   - 在控制台中输入: `NettyTabby`
   - 或搜索关键词: `🖼️` `🎨` `💾` 等表情符号

**提示**: 如果控制台没有显示彩色输出，请确保浏览器支持CSS样式化的console.log
2. **查看控制台**: 观察插件加载和交互日志
3. **检查按钮状态**: 注意工具栏按钮的变化
4. **状态同步**: 如果按钮不实时更新，需要重启Tabby

### ✅ 最新解决方案 (v0.2.2)

**🎯 根本性解决方案：自定义浮动按钮！**

**问题根源**: Tabby的ToolbarButtonProvider架构限制，无法实现实时状态同步。

**解决方案**:
- 🎯 **完全绕过Tabby工具栏系统**
- 🎪 **直接在DOM中注入自定义浮动按钮**
- 🔄 **实时状态监听和UI更新**
- 💫 **美观的动画和交互效果**

**新功能**:
- 🎈 **固定位置浮动按钮** (右上角)
- 📷 ↔ ✅ **毫秒级状态切换**
- 🎯 **动态显示/隐藏取消按钮**
- 🎨 **现代化UI设计**
- 📱 **响应式交互**

### 常见问题

**Q: 插件无法加载**
A: 确保环境变量 `TABBY_PLUGINS` 设置正确，且插件已构建

**Q: 看不到工具栏按钮**
A: 检查Tabby是否以 `--debug` 模式启动

**Q: 按钮状态不更新**
A: 重启Tabby，或检查ToolbarButtonProvider的实时更新机制

**Q: 构建失败**
A: 删除 `node_modules` 重新安装依赖

---

## 🎉 **当前版本总结**

**NettyTabby v0.2.16** - 主题同步和UI优化版本
- 🎨 **主题同步**：选择窗口自动适配Tabby主程序主题
- 🎨 **动态颜色**：使用CSS变量获取当前主题颜色
- 🎨 **一致体验**：背景色、文字色、边框色与主程序完美匹配
- 🎨 **主题按钮**：所有按钮颜色与当前主题协调一致
- 🎨 **智能回退**：主题服务不可用时使用默认颜色
- 🎨 **高对比度**：自动检测主题亮度，提供最佳文字可见度
- 🎨 **优化高亮**：选择状态使用更明显的颜色标识
- 🎨 **紧凑布局**：标题栏和按钮栏高度优化，界面更清爽
- 🎨 **精细字体**：调整字体大小，提升视觉层次感
- 🎨 **自适应高度**：命令区块高度根据内容自动调整，无固定限制
- 🎨 **清晰文本**：修复深色主题下的文字可见性问题
- 🎨 **完整内容显示**：移除按行模式的高度限制，确保所有内容可见
- 🎨 **优化布局**：增加模态框和区块列表的高度空间
- 🎨 **智能换行**：修复CSS样式冲突，确保长行正确换行
- ✅ **实时界面刷新**：切换选择模式时自动重新渲染界面，无需刷新
- ✅ **状态同步**：区块与行选择状态完美同步，切换模式时状态保持
- ✅ **即时切换**：点击开关立即看到界面变化，无延迟
- ✅ **极简设计**：完全移除区块标题和边框，纯净内容显示
- ✅ **高亮标记**：只用边框和背景色标记选择状态，无任何多余UI
- ✅ **行选择开关**：在全选/清空按钮旁添加按行选择开关
- ✅ **行级选择**：按行选择模式下可单独选择每一行
- ✅ **精确微调**：解决命令识别错误，支持精确选择需要的行
- ✅ **智能计数**：行模式显示选中行数，区块模式显示选中区块数
- ✅ **智能导出**：按行模式只导出选中的行内容，支持精确控制
- ✅ **简洁界面**：去掉区块标题和复选框，只用高亮标记选择状态
- ✅ **简化按钮**：去掉按钮数字显示，界面更清爽
- ✅ **自然排序**：区块正序显示，自动滚动到底部符合终端习惯
- ✅ **原始内容**：直接显示终端原始内容，无任何修改
- ✅ **自适应尺寸**：图片宽度和高度完全自适应
- ✅ **智能导出**：支持剪贴板复制和文件下载
- ✅ **彩色日志**：详细的调试信息和操作反馈

---

## 📝 开发计划

1. **Phase 1** ✅: 基础框架和按钮 (已完成)
2. **Phase 2** 🔄: **捕获模式状态管理** (进行中 - 已实现基础状态管理)
3. **Phase 3**: 终端内容访问和区块识别
4. **Phase 4**: 智能区块选择算法
5. **Phase 5**: 图片导出功能 (HTML渲染)
6. **Phase 6**: 配置管理系统和优化

## 🤝 贡献

请按照以下步骤进行开发：

1. 创建功能分支
2. 实现功能
3. 构建测试
4. 提交PR

## 📄 许可证

MIT License
